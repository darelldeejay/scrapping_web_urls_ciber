name: status-check

on:
  workflow_dispatch:
    inputs:
      send_channels:
        description: "Dónde enviar"
        required: true
        default: "none"   # cambia a 'both' si quieres que al lanzar manual SÍ envíe
        type: choice
        options: [none, telegram, teams, both]
      dry_run:
        description: "Solo previsualización (no envía)"
        required: true
        default: "true"   # cambia a 'false' si quieres que al lanzar manual SÍ envíe
        type: boolean
      also_text:
        description: "Incluir versión de texto en el mensaje"
        required: false
        default: "false"
        type: boolean
      impacto:
        description: "Impacto en servicios del cliente (override opcional)"
        required: false
        default: ""
        type: string
      accion:
        description: "Acción sugerida (override opcional)"
        required: false
        default: ""
        type: string
  schedule:
    # 08:30 Madrid (CEST/CET)
    - cron: "30 6 * * *"
    - cron: "30 7 * * *"

concurrency:
  group: dora-status-${{ github.ref }}
  cancel-in-progress: true

jobs:
  vendors:
    name: Scraping vendors
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        vendor: [netskope, proofpoint, qualys, aruba, imperva, cyberark, trendmicro, guardicore]

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Prepare out dirs
        run: mkdir -p .github/out/vendors

      - name: Run ${{ matrix.vendor }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_USER_ID: ${{ secrets.TELEGRAM_USER_ID }}
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          # Captura para el digest (texto por vendor)
          DIGEST_CAPTURE: "1"
          DIGEST_OUT_DIR: .github/out/vendors
          # Dry-run sólo en lanzamientos manuales con dry_run:true
          NOTIFY_DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
        run: |
          # Ejecución normal (mantén tu lógica por vendor)
          python run_vendor.py --vendor ${{ matrix.vendor }}
          # Export JSON para el digest (leerá la captura si existe)
          python run_vendor.py --vendor ${{ matrix.vendor }} --export-json ".github/out/vendors/${{ matrix.vendor }}.json" || true

      - name: Upload vendor summary (per-vendor artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vendor-${{ matrix.vendor }}
          path: .github/out/vendors/${{ matrix.vendor }}.json
          if-no-files-found: ignore
          retention-days: 7

  digest:
    name: Build & send digest
    runs-on: ubuntu-latest
    needs: vendors
    if: always()
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Download vendor summaries (merge all)
        uses: actions/download-artifact@v4
        with:
          pattern: vendor-*
          merge-multiple: true
          path: .github/out/vendors
        continue-on-error: true

      # NUEVO: escribir overrides de forma segura (escapa comillas/ñ/acentos)
      - name: Write optional overrides
        env:
          IMPACTO: ${{ inputs.impacto }}
          ACCION: ${{ inputs.accion }}
        run: |
          python - <<'PY'
          import json, os, pathlib
          d = {}
          imp = os.getenv("IMPACTO") or ""
          acc = os.getenv("ACCION") or ""
          if imp.strip():
              d["IMPACTO_CLIENTE_SI_NO"] = imp
          if acc.strip():
              d["ACCION_SUGERIDA"] = acc
          out = pathlib.Path(".github/out/overrides.json")
          out.parent.mkdir(parents=True, exist_ok=True)
          with out.open("w", encoding="utf-8") as f:
              json.dump(d, f, ensure_ascii=False, indent=2)
          print("overrides:", d)
          PY

      - name: Build digest data JSON
        run: |
          python scripts/build_digest_data.py \
            --vendors-dir .github/out/vendors \
            --out .github/out/digest_data.json \
            --overrides .github/out/overrides.json

      - name: Compute flags
        id: flags
        run: |
          CHANNELS="${{ inputs.send_channels }}"
          [ -z "$CHANNELS" ] && CHANNELS="both"
          DRY="${{ inputs.dry_run }}"
          [ -z "$DRY" ] && DRY="false"
          ALSO="${{ inputs.also_text }}"
          [ -z "$ALSO" ] && ALSO="false"
          echo "CHANNELS=$CHANNELS" | tee -a $GITHUB_STEP_SUMMARY
          echo "NOTIFY_DRY_RUN=$DRY" | tee -a $GITHUB_STEP_SUMMARY
          echo "ALSO_TEXT=$ALSO" | tee -a $GITHUB_STEP_SUMMARY
          echo "CHANNELS=$CHANNELS" >> $GITHUB_ENV
          echo "NOTIFY_DRY_RUN=$DRY" >> $GITHUB_ENV
          echo "ALSO_TEXT=$ALSO" >> $GITHUB_ENV

      # Verifica secrets solo del/los canal/es seleccionados
      - name: Verify notify secrets (only for selected channels)
        if: env.NOTIFY_DRY_RUN == 'false' && env.CHANNELS != 'none'
        run: |
          missing=0
          case "${{ env.CHANNELS }}" in
            telegram)
              if [ -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then echo "Missing TELEGRAM_BOT_TOKEN"; missing=1; fi
              if [ -z "${{ secrets.TELEGRAM_USER_ID }}" ]; then echo "Missing TELEGRAM_USER_ID"; missing=1; fi
              ;;
            teams)
              if [ -z "${{ secrets.TEAMS_WEBHOOK_URL }}" ]; then echo "Missing TEAMS_WEBHOOK_URL"; missing=1; fi
              ;;
            both)
              if [ -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then echo "Missing TELEGRAM_BOT_TOKEN"; missing=1; fi
              if [ -z "${{ secrets.TELEGRAM_USER_ID }}" ]; then echo "Missing TELEGRAM_USER_ID"; missing=1; fi
              if [ -z "${{ secrets.TEAMS_WEBHOOK_URL }}" ]; then echo "Missing TEAMS_WEBHOOK_URL"; missing=1; fi
              ;;
          esac
          if [ "$missing" -eq 1 ]; then
            echo "Required secrets for selected channel(s) are missing; aborting send." >&2
            exit 1
          fi

      - name: Send digest
        if: env.CHANNELS != 'none'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_USER_ID: ${{ secrets.TELEGRAM_USER_ID }}
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
          NOTIFY_DRY_RUN: ${{ env.NOTIFY_DRY_RUN }}
        run: |
          CMD="python run_digest.py \
            --text-template templates/dora_email.txt \
            --html-template templates/dora_email.html \
            --data .github/out/digest_data.json \
            --channels \"$CHANNELS\""
          if [ "$ALSO_TEXT" = "true" ]; then
            CMD="$CMD --also-text"
          fi
          if [ "$NOTIFY_DRY_RUN" = "true" ]; then
            CMD="$CMD --preview-out .github/out/preview"
          fi
          echo "[RUN] $CMD"
          eval $CMD

      # Genera siempre el preview del "correo" (texto + HTML) para auditoría
      - name: Always build preview artifact (even if sent)
        run: |
          python run_digest.py \
            --text-template templates/dora_email.txt \
            --html-template templates/dora_email.html \
            --data .github/out/digest_data.json \
            --channels none \
            --preview-out .github/out/preview \
            --also-text

      - name: Upload digest preview
        uses: actions/upload-artifact@v4
        with:
          name: digest-preview
          path: |
            .github/out/preview/**
            .github/out/digest_data.json
          if-no-files-found: error
